# Задачи - ООП, Седмица 11, 09.05.2024

*Този файл е копие на задачите от: [syndamia.com/teaching/oop-2023/week11](https://syndamia.com/teaching/oop-2023/week11)*

## Преговорни

&:warn Моля, не отделяйте на преговорните задачи повече от 30мин

&:important Всеки бащин клас, във всички случаи, трябва да има виртуален деструктор (`virtual ~ClassName();`).

### Задача 1 - Шаблони и оператори


Реализирайте шаблонен клас множество, който запазва фиксиран брой елементи от подаден тип.
Реализирайте голяма петица и оператори:

- `+`, `+=` които действат като обединение
- `*`, `*=` които действат като сечение
- `-`, `-=` които действат като допълнение

### Задача 2 - Наследяване


Реализирайте клас `Employee`, съхраняващ име на човек, позиция и департамент като низове със съответно дължина 512, 128 и 64, заедно със заплата като число с плаваща запетая.

Реализирайте негов наследник `Manager`, който допълнително пази масив с фиксиран размер от Employee.

Реализирайте наследника на `Employee`, `Developer`, който допълнително пази брой проекти върху който работи.

Наследниците не могат да достъпят заплатата, но трябва да могат да достъпят другите данни на `Employee`.

## Лесни

### Задача 3


<!-- Динамично свързване, Inherit 3 -->

Реализирайте клас `Electronics`, който съдържа модел (низ с максимална дължина от 255 знака), `needsVolts` и `needsAmps` (стойности с плаваща запетая).

Имплементирайте негови наследници:

- `Laptop`, който допълнително съхранява размер на екрана като число с плаваща запетая
- `WashingMachine`, който допълнително запазва максимално тегло на прането, като цяло неотрицателно число
- `Camera`, която допълнително запазва резолюция като число с плаваща запетая (в мегапиксели)

За всеки клас реализирайте член-функция `Print`, която изкарва всички данни на екрана.

&:question Чрез статично или динамично свързване сте имплементирали `Print`? Каква е разликата?

### Задача 4


<!-- Dynamic linking, Inherit 2 -->

Реализирайте клас `String`, който запазва динамично-заделен масив.

Имплементирайте негов наследник `Name`, който допълнително запазва число: номер на името (първо име, бащино име (второ име), фамилия (трето име)).

Имплементирайте втори наследник на `String`, `Street`, който запазва и число: номер на улицата.

Във всеки клас имплементирайте голяма петица, член-функция `Length`, като:

- в `String` връща дължината на низа,
- в `Name` връща дължината на името умножена по номера си и
- в `Street` връща дължината на името на улицата плюс броя цифри в номера на улицата.

Самият низ в `String` **не** може да се достъпва от наследниците.

### Задача 5


<!-- Templates 1 type -->

Реализирайте шаблонен клас `Counted`, който запазва елемент от подаден тип и неговата бройка (цяло неотрицателно число).
Имплементирайте оператори `++`, `--`, `+=`, `-=`, които променят бройката, както и гетъри за елемента и бройката.

### Задача 6


<!-- Templates 2 types -->

Реализирайте шаблонен клас `TwoArray`, който запазва два динамично-заделени масива с подадени типове.
Масивите не могат да се оразмеряват и имат еднаква дължина.

Имплементирайте:

- голяма петица,
- оператор `[]`, който по подаден индекс връща елемент от първия масив, и
- оператор `()`, който по подаден индекс връща елемент от втория масив.

### Задача 7


<!-- Abstract class -->

Реализирайте абстрактен клас `DynamicArray`, който задължава наследниците да имплементират оператор `[]` и оператор `+=`.

Реализирайте негови наследници:

- `Numbers`, който "имплементира" динамично-заделен масив от цели числа, като
  + оператор `[]` връща първия елемент, по-малък от подадения индекс. Ако няма такъв, връщате първия елемент.
  + оператор `+=` вмъква елементите в началото на масива
- `String`, който "имплементира" динамично-заделен масив от букви, като
  + оператор `[]` връща индекс на брой (първата, втората, ...) главна буква в низа. Ако няма такава, тогава връща последната буква.
  + оператор `+=` вмъква елементите в края на масива

Имплементирайте голяма петица.

&:question Къде ще имплементирате динамичния масив и голямата петица?

&:question Можем ли да използваме оператор `+=` в полиморфна йерархия?

### Задача 8


<!-- Abstract class -->

Имплементирайте абстрактен клас `Message`, който съдържа динамично-заделен низ (текстово съобщение, което се показва на екрана) и задължава наследниците да имплементират:

- метод `size`, който връща общия размер на всички данни в байтове.

Реализирайте негов наследник `Link` (хипервръзка), който запазва и втори динамично-заделен низ, запазващ адресът към който линкът сочи.

Реализирайте втори негов наследник `Location`, чието текстово съдържание е адрес, и който допълнително запазва две стойности с плаваща запетая: една за географска ширина и втора за географска дължина.

За всички класове реализирайте член-функция `Length`, която връща размера на **текстовото съобщение** и оператор `<<`.

&:question Има ли разлика между оператор `<<` на трите класа?

### Задача 9


Реализирайте абстрактен шаблонен клас `MixedArray`, който съхранява алтерниращи елементи от два типа.
Тоест, на индекс 0 имаме елемент от първия тип, на индекс 1 от втория, на индекс 2 от първи и так. нат.

Елементите не е нужно да могат да се конвертират помежду си (тоест не може да използвате полиморфен контейнер), затова се достъпват с член функция `At`, приемаща индекс и референции към указатели към всеки тип.
При подаден индекс, на единия указател се записва адресът на съответната стойност, а на другия `nullptr`.

Също имплементира голяма петица и задължава наследниците да имплементират оператори `+=`, върщащи указател.

Реализирайте негов наследник `DirectConcat`, който реализира `+=` като директно слепване (конкатениране).

Реализирайте втори негов наследник, `MixedConcat`, който реализир `+=` като алтернира елемент от първия масив с елемент от втория.

## Трудни

### Задача 10

Реализирайте система за документ с форматиран текст.
В нея всеки елемент от документа е от тип Node, като за един Node трябва да имате:

- id, автоматично-избрано число, с което отличава Node
- operator<<
- operator[]

Реализирайте следните типове Node:

- paragraph, това е най-обикновен низ
- anchor, това е хипервръзка (линк), която съхранява видимо съдържание и уеб адрес
- emplaced link, това е хипервръзка при която видимото съдържание съвпада с уеб адреса
- заглавие, което е като хипервръзка, но уеб адресът започва с '#' и останалото съвпада със текстовото съдържание, като всяка буква е малка и вместо шпации има тирета
- bulletpoint list, който съхранява редица Node-ове и ги изкарва на екрана, всяко на нов ред, започващи с '-'
- table, която съхранява таблица с Node-ове

Имплементирайте клас Document, който запазва масив от Node-ове и за който са имплементирани:

- методи save и load, които запазват и четат цялото съдържание на документа в **текстов** файл с произволен формат.

### Задача 11

Ще реализирате система за изпълнение на крайни автомати (от Теоретични Компютърни науки, ЕАИ).

За тази цел е нужен абстрактен шаблонен клас State, чиито тип определя азбуката, който съхранява динамично-заделен масив от преходи (Transition) и задължава protected имплементация на член-функцията equal, която приема два елемента от азбуката и връща дали са равни.
Имплементирайте голяма петица и оператор +=, който вмъква нов преход в състоянието.

Реализирайте абстрактен шаблонен клас Transition, чиито тип определя азбуката, и който съхранява елемент от този тип (стойността, която ако е равна на подадената ще изпълним прехода) и указател към следващо състояние.
Класът задължава имплементацията на оператор [], който по подаден елемент от азбуката или връща указателя към следващото състояние, или връща nullptr.

Реализирайте наследник на State, ArrayState, който (допускате че) приема указател на динамичо-заделен масив.

Реализирайте наследник на Transition, PrintedTransition, който при всяко извикване на оператор [] също изкарва съобщение на екрана.

Реализирайте клас FiniteStateMachine, който съхранява динамичен масив от състояния.
За него имплементирайте голяма петица и конструктор, приемащ име на текстов файл в CSV формат, в който са запазени:

- на първия ред обща информация във формата "Transitions,StartStateName", след това
- състояния и преходи във формата "StateName,OnValue,TransitionTo", после
- финални състояния във формата "FinalStateName1,FinalStateName2,...", и накрая
- входни букви от азбуката "Letter1,Letter2,...".

Имплементирайте метод Run, който изпълнява автомата и връща булева стойност: дали приема входните букви или не.
