# Задачи - ООП, Седмица 11, 09.05.2024

*Този файл е копие на задачите от: [syndamia.com/teaching/oop-2023/week11](https://syndamia.com/teaching/oop-2023/week11)*

## Преговорни

&:warn Моля, не отделяйте на преговорните задачи повече от 30мин

&:important Ако за даден клас е имплементиран деструктор, тогава в него и всичките му деца трябва да добавите `virtual` пред деструктора!

### Задача 1 - Шаблони и оператори

Реализирайте шаблонен клас множество, който запазва фиксиран брой елементи от подаден тип.
Реализирайте голяма петица и оператори:

- +, += които действат като обединение
- \*, \*= които действат като сечение
- -, -= които действат като допълнение

### Задача 2 - Наследяване

Реализирайте клас Employee, съхраняващ име на човек, позиция и департамент като низове със съответно дължина 512, 128 и 64, заедно със заплата като число с плаваща запетая.

Реализирайте негов наследник Manager, който допълнително пази масив с фиксиран размер от Employee.

Реализирайте наследника на Employee, Developer, който допълнително пази брой проекти върху който работи.

Наследниците не могат да достъпят заплатата, но трябва да могат да достъпят другите данни на Employee.

## Лесни

### Задача 3

<!-- Динамично свързване, Inherit 3 -->

Реализирайте клас Electronics, който съдържа модел (низ с максимална дължина от 255 знака), needsVolts и needsAmps (стойности с плаваща запетая).

Имплементирайте негови наследници:

- Laptop, който допълнително съхранява размер на екрана като число с плаваща запетая
- WashingMachine, който допълнително запазва максимално тегло на прането, като цяло неотрицателно число
- Camera, която допълнително запазва резолюция като число с плаваща запетая (в мегапиксели)

За всеки клас реализирайте член-функция Print, която изкарва всички данни на екрана.

&:question Чрез статично или динамично свързване сте имплементирали Print? Каква е разликата?

### Задача 4

<!-- Dynamic linking, Inherit 2 -->

Реализирайте клас String, който запазва динамично-заделен масив.

Имплементирайте негов наследник Name, който допълнително запазва число: номер на името (първо име, бащино име (второ име), фамилия (трето име)).

Имплементирайте втори наследник на String, Street, който запазва и число: номер на улицата.

Във всеки клас имплементирайте голяма петица, член-функция length, като в String връща дължината на низа, в Name връща дължината на името умножена по номера си и в Street връща дължината на името на улицата плюс броя цифри в номера на улицата.

### Задача 5

<!-- Templates 1 type -->

Реализирайте шаблонен клас Counted, който запазва елемент от подаден тип и неговата бройка (цяло неотрицателно число).
Имплементирайте оператори ++, --, +=, -=, които променят бройката.

### Задача 6

<!-- Templates 2 types -->

Реализирайте шаблонен клас TwoArray, който запазва два динамично-заделени масива с подадени типове.
Масивите не могат да се оразмеряват и имат еднаква дължина.

Имплементирайте голяма петица, оператор [], който по подаден индекс връща елемент от първия масив, и оператор (), който по подаден индекс връща елемент от втория масив.

### Задача 7

<!-- Abstract class -->

Реализирайте абстрактен клас DynamicArray, който задължава наследниците да имплементират оператор [], оператор += и оператор +.

Реализирайте негови наследници String, който имплементира динамично-заделен масив от букви, и Numbers, който имплементира динамично-заделен масив от числа.
Имплементирайте голяма петица.

### Задача 8

<!-- Abstract class -->

Имплементирайте абстрактен клас Message, който съдържа динамично-заделен низ (текстово съобщение) и задължава наследниците да имплементират метод size, който връща общия размер на всички данни в байтове.

Реализирайте негов наследник Link (хипервръзка), който запазва и втори динамично-заделен низ, запазващ адресът към който линкът сочи.

Реализирайте втори негов наследник Location, чието текстово съдържание е адрес, и който допълнително запазва две стойности с плаваща запетая: една за географска ширина и втора за географска дължина.

За всички класове реализирайте член-функция length, която връща размера на текстовото съобщение и operator<<.

### Задача 9

Реализирайте абстрактен шаблонен клас MixedArray, който съхранява алтерниращи елементи от два типа, за тях имплементира голяма петица и задължава наследниците да имплементират оператори + и +=.
Елементите не е нужно да могат да се конвертират помежду си (тоест не може да използвате полиморфен контейнер).

Реализирайте негов наследник DirectConcat, който реализира + и += като директно слепване (конкатениране).

Реализирайте втори негов наследник, MixedConcat, който реализир + и += като алтернира елемент от първия масив с елемент от втория.

## Трудни

### Задача 10

Реализирайте система за документ с форматиран текст.
В нея всеки елемент от документа е от тип Node, като за един Node трябва да имате:

- id, автоматично-избрано число, с което отличава Node
- operator<<
- operator[]

Реализирайте следните типове Node:

- paragraph, това е най-обикновен низ
- anchor, това е хипервръзка (линк), която съхранява видимо съдържание и уеб адрес
- emplaced link, това е хипервръзка при която видимото съдържание съвпада с уеб адреса
- заглавие, което е като хипервръзка, но уеб адресът започва с '#' и останалото съвпада със текстовото съдържание, като всяка буква е малка и вместо шпации има тирета
- bulletpoint list, който съхранява редица Node-ове и ги изкарва на екрана, всяко на нов ред, започващи с '-'
- table, която съхранява таблица с Node-ове

Имплементирайте клас Document, който запазва масив от Node-ове и за който са имплементирани:

- методи save и load, които запазват и четат цялото съдържание на документа в **текстов** файл с произволен формат.

### Задача 11

Ще реализирате система за изпълнение на крайни автомати (от Теоретични Компютърни науки, ЕАИ).

За тази цел е нужен абстрактен шаблонен клас State, чиито тип определя азбуката, който съхранява динамично-заделен масив от преходи (Transition) и задължава protected имплементация на член-функцията equal, която приема два елемента от азбуката и връща дали са равни.
Имплементирайте голяма петица и оператор +=, който вмъква нов преход в състоянието.

Реализирайте абстрактен шаблонен клас Transition, чиито тип определя азбуката, и който съхранява елемент от този тип (стойността, която ако е равна на подадената ще изпълним прехода) и указател към следващо състояние.
Класът задължава имплементацията на оператор [], който по подаден елемент от азбуката или връща указателя към следващото състояние, или връща nullptr.

Реализирайте наследник на State, ArrayState, който (допускате че) приема указател на динамичо-заделен масив.

Реализирайте наследник на Transition, PrintedTransition, който при всяко извикване на оператор [] също изкарва съобщение на екрана.

Реализирайте клас FiniteStateMachine, който съхранява динамичен масив от състояния.
За него имплементирайте голяма петица и конструктор, приемащ име на текстов файл в CSV формат, в който са запазени:

- на първия ред обща информация във формата "Transitions,StartStateName", след това
- състояния и преходи във формата "StateName,OnValue,TransitionTo", после
- финални състояния във формата "FinalStateName1,FinalStateName2,...", и накрая
- входни букви от азбуката "Letter1,Letter2,...".

Имплементирайте метод Run, който изпълнява автомата и връща булева стойност: дали приема входните букви или не.
