# Задачи - ООП, Седмица 1, 22.02.2024

*Този файл е копие на задачите от: [syndamia.com/teaching/oop-2023/week1](https://syndamia.com/teaching/oop-2023/week1)*

## Задача 1

Имплементирайте низ чрез структура.
В структурата трябва да запазвате указател към низа и неговата дължина.

Имплементирайте функция `concatString`, която приема две структури от този тип и връща низ, пак в същата структура, който е конкатенация (слепване) на първите два низа.

&&question Има ли значение дали типовете на аргументите, или на върнатата стойност, са референции или указатели (или нито едното)?

В самия код тествайте функциите (не е нужен потребителски вход).

## Задача 2

Имплементирайте структура за динамично-заделен масив от целочислени числа.
Тя трябва да запазва указател към масива, размера на масива и бройката на елементи в масива.

Заделянето на динамична памет е бавна операция, затова винаги ще заделяме повече клетки, отколкото са ни нужни.

Имплементирайте функция `resize`, която удвоява размера на масива (нека първоначалния размер на масива е 2), на подадена стойност от тип вашата структура.

Имплементирайте функция `addToEnd`, която приема (инстанция на) структурата ви и вмъква елемент в първата незаета позиция.

В самия код тествайте функциите (не е нужен потребителски вход).

## Задача 3

Разглеждате "пакети" (логове) информация от редица датчици.
Един пакет запазва времето, когато информацията е била отчетена от датчиците, и стойностите на всички датчици: температура, атмосферно налягане, влажност и надморска височина.
Всички типове данни са целочислени.

От входа получавате N, броя пакети, които трябва да запазите, и след това 5N на брой целочислени стойности.
Накрая получавате буква: `t`, `p`, `h`, `e`, всяка съответства на някоя отделна стойност от датчиците.

Трябва да изкарате на екрана всичките стойности от пакетите, подредени в нарастващ ред на времето, като всички след първата са разликите им спрямо първата.

**Пример:**

|Вход|Изход|
|----|-----|
|6<br>56 45 64 -8 98<br>14 40 -15 -18 -1<br>22 89 72 62 4<br>85 44 60 17 13<br>75 18 -12 48 21<br>27 10 94 -5 16<br>p|-15 87 109 79 3 75|

## Задача 4

Направете структура за съхранение на полети[^sabre].
Трябва да запазите имената на началния и крайния град като низове (допускаме, че няма шпации в имената на градовете), часът на излитане и на кацане в целочислен формат (като на циферблат на дигитален часовник, без разделителното двоеточие) и цената на полета в тип с плаваща запетая (в долари).

### а) въвеждане

От входа получавате N, това определя броя полети, които трябва да се добавят в системата.
Всеки полет е редица от 5 стойности, в реда в който са дефинирани.

*Напомням, че това е нагласено да ползвате `std::cin` вместо ръчно да обработвате целия ред.*

Изкарайте началните и крайните градове, както и цената на полетите, подредени в нарастващ ред на час на излитане.

**Пример:**

|Вход|Изход|
|----|-----|
|5<br>Berlin Paris 1105 1255 140<br>Sofia Paris 0915 1115 140<br>Paris NewYork 1225 1610 500<br>Sofia NewYork 0610 1345 800<br>Sofia Berlin 1020 1130 200|Sofia NewYork 800<br>Sofia Paris 140<br>Sofia Berlin 200<br>Berlin Paris 140<br>Paris NewYork 500|

### б) търсене

След като се въведат всички полети, получавате от входа два низа - имена на градове.
Трябва да изкарате най-евтиния, и след него най-бързия, вариант за пътуване от първия град към втория.

Прикачване между полети е позволено, така че под "вариант" трябва да изкарате всичките полети, които са решение.
За един полет е нужно да изкарате само началния град, крайния град, час на излитане и цена, като градовете трябва да са подредени в нарастващ ред на часа на излитане.

**Пример:**

|Вход|Изход|
|----|-----|
|5<br>Berlin Paris 1105 1255 140<br>Sofia Paris 0915 1115 140<br>Paris NewYork 1225 1610 500<br>Sofia NewYork 0610 1245 800<br>Sofia Berlin 1020 1130 200<br>Sofia NewYork|Cheapest:<br>Sofia Paris 0915 140<br>Paris NewYork 1225 500<br>Quickest:<br>Sofia NewYork 0610 800|


## Задача 5

Имате система за потребители, всеки потребител си има име и приятели (един приятел е **указател към потребител**).

В началото се въвежда N, това е броят потребители в системата.
За един потребител, първо се въвежда на нов ред името му, след това броя на неговите приятели и накрая, на отделни редове, имената на всички тези приятели.

Накрая получавате едно име, това е началния потребител.
Трябва да намерите, започвайки от него, с колко други потребителя има някаква приятелска връзка (директна, приятел на приятел, приятел на приятел на приятел, ...).

**Пример:**

|Вход|Изход|
|----|-----|
|5<br>Георги<br>2<br>Асен Гьонов<br>Майстора<br>Асен Гьонов<br>2<br>Георги<br>др. Божидаров<br>Майстора<br>1<br>Георги<br>др. Божидаров<br>1<br>Асен Гьонов<br>Павел<br>0<br>Майстора|3|

[^sabre]: Защото една от първите индустрии, които са се нуждаели от компютърни системи, била [авиационната индустрия](https://en.wikipedia.org/wiki/Sabre_%28travel_reservation_system%29#History).
